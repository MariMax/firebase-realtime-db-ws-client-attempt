<!DOCTYPE html>
<html lang="en">

<head>
  <script>
    class PubSubEvent {
      constructor(topic, payload) {
        this.topic = topic;
        this.payload = payload;
      }
    }

    class PubSub {
      static subscribe(topic, cb) {
        const subscrMap = PubSub._subscriptions || new Map();
        PubSub._subscriptions = subscrMap;
        const topicSubscriptions = subscrMap.get(topic) || [];
        topicSubscriptions.push(cb);
        PubSub._subscriptions.set(topic, topicSubscriptions);
        return () => {
          let subscriptions = PubSub._subscriptions.get(topic) || [];
          subscriptions = subscriptions.filter(i => i !== cb);
        }
      }

      static emit(pubSubEvent) {
        if (!PubSub._subscriptions) return;
        const topic = pubSubEvent.topic;
        const subscriptions = PubSub._subscriptions.get(topic) || [];
        subscriptions.forEach(i => i(pubSubEvent));
      }
    }

    class Deferred {
      constructor() {
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }

      resolve(value) {
        this._resolve(value);
      }

      reject(reason) {
        this._reject(reason);
      }

      get promise() {
        return this._promise;
      }
    }

    class Subscription {
      constructor(path, cb, unsubscribe, defer) {
        this.path = path;
        this.cb = cb;
        this.status = 0;

        this._unsubscribe = unsubscribe;

        defer.promise
          .then(() => this.status = 1)
          .catch(() => this.status = -1);
      }

      unsubscribe() {
        this._unsubscribe();
      }
    }

    class ConnectionManager {
      constructor(url) {
        this._messagesQueue = [];
        this._helloMessage = '{"t":"d","d":{"r":1,"a":"s","b":{"c":{"sdk.js.5-4-1":1}}}}';
        this._expectedHelloResponse = '{"t":"d","d":{"r":1,"b":{"s":"ok","d":""}}}';
        this._pingMessage = '{"t":"c","d":{"t":"p","d":{}}}';
        this._expectedPongMessage = '{"t":"c","d":{"t":"o","d":null}}';
        this._connectionEstablished = false;
        this._messageNumber = 0;
        this._url = url;
        this._reconnectPeriod = 1000;
        this._pingPeriod = 60000;
        this._connectionAttempt = 0;
        this._timeoutHandler = -1;
        this._pingTimeoutHandler = -1;
        this._reconnect();
      }

      get connectionStatus() {
        return this._connectionEstablished ? 1 : 0;
      }

      _bindEvents() {
        this._ws.addEventListener('open', (ev) => this._onOpen(ev));
        this._ws.addEventListener('message', (ev) => this._onMessage(ev));
        this._ws.addEventListener('close', (ev) => this._onClose(ev));
        this._ws.addEventListener('error', (ev) => this._onError(ev));
      }

      _onOpen(ev) {
        console.log('open', ev);
        this._messageNumber = 0;
        clearTimeout(this._timeoutHandler);
        this._resetPing();
        while (this._messagesQueue.length > 0) {
          const message = this._messagesQueue.pop();
          this.send(message);
        };
        PubSub.emit({
          topic: 'WsEvents',
          payload: 'open'
        });
      }

      _onMessage(ev) {
        this._handleMessage(ev.data);
      }

      _onClose(ev) {
        console.log('close', ev);
        this._reconnect();
      }

      _onError(ev) {
        console.log('error', ev);
        this._ws.close();
      }

      _reconnect() {
        if (this._ws && (
          this._ws.readyState === this._ws.OPEN ||
          this._ws.readyState === this._ws.CONNECTING)) return;
        this._connectionEstablished = false;
        this._connectionAttempt++;
        this._ws = new WebSocket(this._url);
        this._bindEvents();
        this._timeoutHandler = setTimeout(() => this._reconnect(), this._reconnectPeriod);
      }

      _resetPing() {
        clearTimeout(this._pingTimeoutHandler);
        this._pingTimeoutHandler = setTimeout(() => { this._ping(); this._resetPing() }, this._pingPeriod);
      }
      _ping() { this._ws.send(0) }

      _handleMessage(data) {
        if (this._messageNumber === 0) { this._messageNumber++; this.send(this._helloMessage) }
        if (this._expectedHelloResponse === data) { return this.send(this._pingMessage) }
        if (this._expectedPongMessage === data) { return this._connectionEstablished = true }

        PubSub.emit({
          topic: 'Message',
          payload: data
        });
      }

      send(data) {
        if (this._ws.readyState !== this._ws.OPEN) {
          this._messagesQueue.push(data);
        }
        this._ws.send(data);
        this._resetPing();
      }
    }

    class SubscriptionManager {
      constructor(connectionManager) {
        this._messageId = 0;
        this._subscriptions = [];
        this._pendingSubscriptions = [];
        this._cm = connectionManager;
        this._wsStateSubscription = PubSub.subscribe('WsEvents', (ev) => this._onWsStateChange(ev.payload));
        this._dataSubscription = PubSub.subscribe('Message', (ev) => this._onMessage(ev.payload));
      }

      _onWsStateChange(state) {
        switch (state) {
          case 'open': {
            this._resubscribe();
          }
        }
      }

      _resubscribe() {
        // TODO: implement...
        // firebase should know what to send back, here we probably created new WS, 
        // because old one was closed or failed in some way
      }

      _removePendingSubscription(subscription) {
        this._pendingSubscriptions = this._pendingSubscriptions.filter(i => i !== subscription);
      }

      _onMessage(data) {
        const subscription = this._pendingSubscriptions.find(i => i.expectedResponse === data);
        if (subscription) {
          subscription.defer.resolve(subscription.subscription);
          this._removePendingSubscription(subscription);
          return
        }
        if (/{"t":"d","d":{"r":\d/.test(data)) {
          const d = data.replace('{"t":"d","d":{"r":', '');
          const messageId = parseInt(d, 10);
          const failedSubscription = this._pendingSubscriptions.find(i => i.messageId === messageId);
          if (failedSubscription) {
            failedSubscription.defer.reject(data);
            this._removePendingSubscription(failedSubscription);
            return;
          }
        }
      }

      subscribe(path, cb) {
        const messageId = this._messageId++;
        const subscribeMessage = `{"t":"d","d":{"r":${messageId},"a":"q","b":{"p":"${path}","h":""}}}`;
        const expectedResponse = `{"t":"d","d":{"r":${messageId},"b":{"s":"ok","d":{}}}}`
        const defer = new Deferred();
        const subscription = new Subscription(
          path,
          cb,
          () => this._subscriptions = this._subscriptions.filter(i => i !== subscription),
          defer
        );
        this._subscriptions.push(subscription);
        this._pendingSubscriptions.push({ messageId, defer, expectedResponse, subscription })
        this._cm.send(subscribeMessage);
        return defer.promise;
      }

    }

    const cm = new ConnectionManager('wss://<db-name>.firebaseio.com/.ws?v=5&ns=<db-name>');
    const sm = new SubscriptionManager(cm);




  </script>
</head>

<body>
</body>

</html>